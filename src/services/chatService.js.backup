import { webhookService } from './webhookService';
import simpleFileUpload from './simpleFileUpload.js';

// Simulate API delay
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

export const chatService = {
  // Validate file type - ch·ªâ cho ph√©p images, doc, pdf
  validateFileType(file) {
    const allowedImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
    const allowedDocTypes = [
      'application/pdf',
      'application/msword', // .doc
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document' // .docx
    ];
    
    const fileType = file.type.toLowerCase();
    const fileName = file.name.toLowerCase();
    
    // Check images
    if (allowedImageTypes.includes(fileType)) {
      return { valid: true, type: 'image', category: 'image' };
    }
    
    // Check documents
    if (allowedDocTypes.includes(fileType) || 
        fileName.endsWith('.pdf') || 
        fileName.endsWith('.doc') || 
        fileName.endsWith('.docx')) {
      return { valid: true, type: 'document', category: 'document' };
    }
    
    return { 
      valid: false, 
      type: 'unsupported',
      message: 'Ch·ªâ h·ªó tr·ª£ file h√¨nh ·∫£nh (JPG, PNG, GIF, WebP) v√† t√†i li·ªáu (PDF, DOC, DOCX)'
    };
  },

  // Get file processing strategy - ch·ªâ upload ƒë·ªÉ l·∫•y HTTP URL
  getFileProcessingStrategy(file) {
    const validation = this.validateFileType(file);
    
    if (!validation.valid) {
      return {
        strategy: 'unsupported',
        supportedByAI: false,
        processing: 'none',
        description: validation.message
      };
    }
    
    return {
      strategy: 'url_upload',
      supportedByAI: true,
      processing: 'http_url',
      category: validation.category,
      description: `${validation.type === 'image' ? 'H√¨nh ·∫£nh' : 'T√†i li·ªáu'} s·∫Ω ƒë∆∞·ª£c upload v√† chuy·ªÉn th√†nh HTTP URL`,
      fileType: validation.type
    };
  }
    
    // Images - use URL link instead of base64 for better performance
    if (fileType.startsWith('image/')) {
      return {
        strategy: 'vision',
        supportedByAI: true,
        processing: useUrl ? 'url' : 'base64',
        description: useUrl ? 'Image URL for AI vision analysis' : 'Image for AI vision analysis'
      };
    }
    
    // Text files - extract content
    if (fileType.startsWith('text/') || 
        fileName.endsWith('.txt') || 
        fileName.endsWith('.md') || 
        fileName.endsWith('.csv') ||
        fileName.endsWith('.json') ||
        fileName.endsWith('.xml')) {
      return {
        strategy: 'text',
        supportedByAI: true,
        processing: 'text_content',
        description: 'Text content for AI analysis'
      };
    }
    
    // Code files - extract content
    if (fileName.endsWith('.js') || fileName.endsWith('.jsx') ||
        fileName.endsWith('.ts') || fileName.endsWith('.tsx') ||
        fileName.endsWith('.py') || fileName.endsWith('.java') ||
        fileName.endsWith('.cpp') || fileName.endsWith('.c') ||
        fileName.endsWith('.css') || fileName.endsWith('.html')) {
      return {
        strategy: 'code',
        supportedByAI: true,
        processing: 'text_content',
        description: 'Code file for AI analysis'
      };
    }
    
    // Default - metadata only
    return {
      strategy: 'unknown',
      supportedByAI: false,
      processing: 'metadata',
      description: 'File type not directly supported',
      note: 'Only metadata will be sent to AI'
    };
  },

  // Send message to AI
  async sendMessage(message, files = [], conversationHistory = [], onProgressUpdate = null) {
    console.log('üì§ Sending message:', message);
    
    try {
      // Create chat data with proper structure for AI processing
      const chatData = {
        message: message,
        files: files,
        conversationHistory: conversationHistory,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        sessionId: Date.now().toString()
      };

      console.log('ÔøΩ Chat data prepared:', chatData);

      // Show initial loading message
      if (onProgressUpdate) {
        onProgressUpdate('üîç ƒêang x·ª≠ l√Ω...');
      }

      // Send to webhook with enhanced error handling and progress tracking
      const webhookPromise = webhookService.sendChatMessage(chatData);
      
      // Set up progress updates
      const progressTimer = setTimeout(() => {
        if (onProgressUpdate) {
          onProgressUpdate('ü§ñ AI ƒëang ph√¢n t√≠ch...');
        }
      }, 3000); // After 3 seconds
      
      const longProgressTimer = setTimeout(() => {
        if (onProgressUpdate) {
          onProgressUpdate('‚è≥ ƒêang x·ª≠ l√Ω ph·ª©c t·∫°p...');
        }
      }, 8000); // After 8 seconds

      let webhookResult;
      try {
        webhookResult = await webhookPromise;
        clearTimeout(progressTimer);
        clearTimeout(longProgressTimer);
      } catch (error) {
        clearTimeout(progressTimer);
        clearTimeout(longProgressTimer);
        throw error;
      }
      
      // Continue with existing logic
      // If axios fails, try with fetch as fallback
      if (!webhookResult.success) {
        if (onProgressUpdate) {
          onProgressUpdate('üîÑ ƒêang th·ª≠ ph∆∞∆°ng ph√°p k·∫øt n·ªëi kh√°c...');
        }
        
        console.warn('üîÑ Axios failed, trying fetch method...');
        
        // Check if it's an IP restriction error
        if (webhookResult.error && webhookResult.error.includes('IP restriction')) {
          console.warn('üö´ IP restriction detected, skipping fetch fallback and using mock response');
          webhookResult = { success: false, error: 'IP_BLOCKED' };
        } else {
          webhookResult = await webhookService.testWithFetch(chatData);
        }
      }

      let aiResponse;
      if (webhookResult.success && webhookResult.data) {
        // Try multiple response formats from webhook
        if (webhookResult.data.response) {
          aiResponse = webhookResult.data.response;
          console.log('‚úÖ AI Response received (data.response):', aiResponse);
        } else if (webhookResult.data.message) {
          aiResponse = webhookResult.data.message;
          console.log('‚úÖ AI Response received (data.message):', aiResponse);
        } else if (typeof webhookResult.data === 'string') {
          aiResponse = webhookResult.data;
          console.log('‚úÖ AI Response received (string data):', aiResponse);
        } else if (webhookResult.data.text) {
          aiResponse = webhookResult.data.text;
          console.log('‚úÖ AI Response received (data.text):', aiResponse);
        } else {
          // Try to extract any text content from the response
          console.warn('‚ö†Ô∏è No standard AI response found, trying to extract any text content...');
          const responseStr = JSON.stringify(webhookResult.data);
          console.log('üìù Full webhook response data:', webhookResult.data);
          
          // Look for common AI response patterns
          const textFields = ['content', 'answer', 'result', 'output'];
          for (const field of textFields) {
            if (webhookResult.data[field] && typeof webhookResult.data[field] === 'string') {
              aiResponse = webhookResult.data[field];
              console.log(`‚úÖ AI Response found in data.${field}:`, aiResponse);
              break;
            }
          }
          
          if (!aiResponse) {
            console.warn('‚ö†Ô∏è Could not extract AI response from webhook data, using fallback');
            aiResponse = null; // Will trigger fallback
          }
        }
      }
      
      if (!aiResponse) {
        // Fallback to mock response if webhook fails or no response found
        console.warn('‚ö†Ô∏è Webhook failed or no response, using fallback');
        console.warn('Webhook error details:', {
          error: webhookResult.error || 'Unknown error',
          success: webhookResult.success,
          details: webhookResult.details,
          fullData: webhookResult.data
        });
        
        const lowerMessage = message.toLowerCase();
        
        // Check if it's an IP restriction error
        if (webhookResult.error === 'IP_BLOCKED' || (webhookResult.error && webhookResult.error.includes('IP restriction'))) {
          aiResponse = 'üö´ **K·∫øt n·ªëi webhook b·ªã h·∫°n ch·∫ø IP**\n\n' +
                      'Hi·ªán t·∫°i n8n webhook ƒëang ch·∫∑n truy c·∫≠p t·ª´ IP address n√†y. ' +
                      'ƒê√¢y l√† ch·∫ø ƒë·ªô b·∫£o m·∫≠t c·ªßa n8n cloud.\n\n' +
                      '**Gi·∫£i ph√°p:**\n' +
                      '‚Ä¢ S·ª≠ d·ª•ng VPN v·ªõi IP ƒë∆∞·ª£c ph√©p\n' +
                      '‚Ä¢ C·∫•u h√¨nh IP whitelist trong n8n\n' +
                      '‚Ä¢ Tri·ªÉn khai proxy server\n\n' +
                      '_Hi·ªán ƒëang s·ª≠ d·ª•ng ch·∫ø ƒë·ªô offline v·ªõi mock responses._';
        } else if (lowerMessage.includes('xin ch√†o') || lowerMessage.includes('hello')) {
          aiResponse = 'üëã **Xin ch√†o!** T√¥i l√† AI Assistant c·ªßa PingMe.\n\n' +
                      'T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n' +
                      '‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi\n' +
                      '‚Ä¢ Ph√¢n t√≠ch h√¨nh ·∫£nh v√† t√†i li·ªáu\n' +
                      '‚Ä¢ X·ª≠ l√Ω file vƒÉn b·∫£n v√† code\n' +
                      '‚Ä¢ H·ªó tr·ª£ c√¥ng vi·ªác h√†ng ng√†y\n\n' +
                      '_L∆∞u √Ω: Hi·ªán ƒëang s·ª≠ d·ª•ng ch·∫ø ƒë·ªô offline._';
        } else if (lowerMessage.includes('gi√∫p') || lowerMessage.includes('help')) {
          aiResponse = 'üÜò **H·ªó tr·ª£ PingMe AI Assistant**\n\n' +
                      '**T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:**\n' +
                      '‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi t·ªïng quan\n' +
                      '‚Ä¢ Ph√¢n t√≠ch v√† m√¥ t·∫£ h√¨nh ·∫£nh\n' +
                      '‚Ä¢ ƒê·ªçc v√† t√≥m t·∫Øt t√†i li·ªáu\n' +
                      '‚Ä¢ Review v√† gi·∫£i th√≠ch code\n' +
                      '‚Ä¢ H·ªó tr·ª£ d·ªãch thu·∫≠t\n\n' +
                      '**Upload file:** T√¥i h·ªó tr·ª£ nhi·ªÅu ƒë·ªãnh d·∫°ng file kh√°c nhau\n' +
                      '_L∆∞u √Ω: ƒêang ho·∫°t ƒë·ªông ·ªü ch·∫ø ƒë·ªô offline._';
        } else {
          aiResponse = 'ü§ñ **AI Assistant ƒëang offline**\n\n' +
                      `T√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn: "${message}"\n\n` +
                      'Hi·ªán t·∫°i webhook kh√¥ng kh·∫£ d·ª•ng, nh∆∞ng t√¥i v·∫´n c√≥ th·ªÉ:\n' +
                      '‚Ä¢ Nh·∫≠n v√† l∆∞u tr·ªØ tin nh·∫Øn c·ªßa b·∫°n\n' +
                      '‚Ä¢ X·ª≠ l√Ω file upload c∆° b·∫£n\n' +
                      '‚Ä¢ Cung c·∫•p h·ªó tr·ª£ offline\n\n' +
                      '_Khi k·∫øt n·ªëi ph·ª•c h·ªìi, t√¥i s·∫Ω c√≥ th·ªÉ tr·∫£ l·ªùi ƒë·∫ßy ƒë·ªß h∆°n._';
        }
      }

      // Return successful response
      return {
        success: true,
        response: aiResponse,
        source: 'webhook',
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('üí• Error in sendMessage:', error);
      return {
        success: false,
        error: error.message,
        response: '‚ùå **L·ªói h·ªá th·ªëng**\n\nƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω tin nh·∫Øn c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau.'
      };
    }
  },

  // Upload file with comprehensive AI processing support
  async uploadFile(file) {
    await delay(500);
    
    // Validate file size (max 10MB)
    if (file.size > 10 * 1024 * 1024) {
      return {
        success: false,
        message: 'File qu√° l·ªõn. Vui l√≤ng ch·ªçn file nh·ªè h∆°n 10MB.'
      };
    }

    console.log(`üì§ Processing file for AI: ${file.name} (${file.size} bytes)`);

    try {
      // Step 1: Upload file to get public HTTP/HTTPS URL
      const uploadResult = await simpleFileUpload.uploadFile(file);
      
      if (!uploadResult.success) {
        console.error('‚ùå File upload failed:', uploadResult.error);
        return {
          success: false,
          message: `Kh√¥ng th·ªÉ upload file: ${uploadResult.error}`
        };
      }

      console.log(`‚úÖ File uploaded successfully:`, {
        url: uploadResult.url,
        service: uploadResult.uploadService,
        size: uploadResult.fileSize
      });

      // Step 2: Process Excel files to JSON
      let processedData = null;
      if (excelConverter.isExcelFile(file)) {
        console.log(`üìä Converting Excel file to JSON: ${file.name}`);
        try {
          const excelJSON = await excelConverter.convertExcelToJSON(file);
          const aiSummary = excelConverter.createAISummary(excelJSON);
          
          processedData = {
            type: 'excel_json',
            originalFile: file.name,
            summary: aiSummary,
            fullData: excelJSON
          };
          
          console.log(`‚úÖ Excel converted to JSON:`, {
            sheets: excelJSON.summary.totalSheets,
            rows: excelJSON.summary.totalRows,
            size: JSON.stringify(processedData).length
          });
        } catch (error) {
          console.warn(`‚ö†Ô∏è Excel conversion failed for ${file.name}:`, error);
          processedData = null;
        }
      }

      // Create blob URL for UI preview only
      let previewUrl = null;
      try {
        if (file.type.startsWith('image/') && file.size > 0) {
          previewUrl = URL.createObjectURL(file);
          console.log(`üîó Created blob URL for preview: ${file.name}`);
          
          // Auto cleanup after 5 minutes
          setTimeout(() => {
            if (previewUrl) {
              try {
                URL.revokeObjectURL(previewUrl);
                console.log(`‚è∞ Auto-revoked blob URL for: ${file.name}`);
              } catch (e) {
                console.warn(`Failed to auto-revoke blob URL:`, e);
              }
            }
          }, 5 * 60 * 1000);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Could not create blob URL for ${file.name}:`, error);
      }
      
      // Enhanced file data structure
      const fileData = {
        id: `file-${Date.now()}`,
        name: file.name,
        size: file.size,
        type: file.type,
        url: previewUrl, // For UI preview only
        originalFile: file,
        
        // Public URL for webhook (HTTP/HTTPS)
        publicUrl: uploadResult.url,
        uploadService: uploadResult.uploadService,
        
        // Processed data for AI (Excel -> JSON)
        processedData: processedData,
        hasProcessedData: !!processedData,
        
        mimeType: file.type,
        isImage: file.type.startsWith('image/'),
        isExcel: excelConverter.isExcelFile(file),
        isSupported: true // All files are supported with public URLs
      };
      
      console.log(`üìé File ready: ${file.name}`);
      console.log(`üåê Public URL: ${uploadResult.url}`);
      
      return {
        success: true,
        data: fileData
      };
      
    } catch (error) {
      console.error(`üí• Failed to process file ${file.name}:`, error);
      return {
        success: false,
        message: `Kh√¥ng th·ªÉ x·ª≠ l√Ω file: ${error.message}`
      };
    }
  },

  // Get chat history from webhook or fallback to mock
  async getChatHistory(userId) {
    try {
      console.log('üìö Getting chat history for userId:', userId);
      
      // Try to get from webhook first
      const webhookResult = await webhookService.getChatHistory(userId);
      
      if (webhookResult.success && webhookResult.data) {
        console.log('‚úÖ Chat history loaded from webhook');
        
        // Format data if needed (webhook might return different format)
        let historyData = webhookResult.data;
        
        // If webhook returns an array of messages directly
        if (Array.isArray(historyData)) {
          return {
            success: true,
            data: historyData
          };
        }
        
        // If webhook returns object with messages array
        if (historyData.messages && Array.isArray(historyData.messages)) {
          return {
            success: true,
            data: historyData.messages
          };
        }
        
        // If webhook returns something else, try to extract messages
        console.warn('‚ö†Ô∏è Unexpected webhook response format:', historyData);
      }
      
      // Fallback to mock data if webhook fails
      console.warn('‚ö†Ô∏è Webhook failed, using mock chat history');
      await delay(500);
      
      return {
        success: true,
        data: [
          {
            id: 'msg-1',
            content: 'Xin ch√†o! T√¥i l√† AI assistant c·ªßa PingMe. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?',
            timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(),
            sender: 'ai'
          }
        ]
      };
      
    } catch (error) {
      console.error('‚ùå Error getting chat history:', error);
      
      // Return empty history on error
      return {
        success: false,
        data: [],
        error: error.message
      };
    }
  },

  // Check webhook health status
  async checkWebhookHealth() {
    return await checkWebhookHealth();
  }
};